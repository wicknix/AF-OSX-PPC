// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: csd.proto

#ifndef PROTOBUF_csd_2eproto__INCLUDED
#define PROTOBUF_csd_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace safe_browsing {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_csd_2eproto();
void protobuf_AssignDesc_csd_2eproto();
void protobuf_ShutdownFile_csd_2eproto();

class ClientDownloadRequest;
class ClientDownloadRequest_Digests;
class ClientDownloadRequest_Resource;
class ClientDownloadRequest_CertificateChain;
class ClientDownloadRequest_CertificateChain_Element;
class ClientDownloadRequest_SignatureInfo;
class ClientDownloadRequest_PEImageHeaders;
class ClientDownloadRequest_PEImageHeaders_DebugData;
class ClientDownloadRequest_ImageHeaders;
class ClientDownloadResponse;
class ClientDownloadResponse_MoreInfo;

enum ClientDownloadRequest_ResourceType {
  ClientDownloadRequest_ResourceType_DOWNLOAD_URL = 0,
  ClientDownloadRequest_ResourceType_DOWNLOAD_REDIRECT = 1,
  ClientDownloadRequest_ResourceType_TAB_URL = 2,
  ClientDownloadRequest_ResourceType_TAB_REDIRECT = 3
};
bool ClientDownloadRequest_ResourceType_IsValid(int value);
const ClientDownloadRequest_ResourceType ClientDownloadRequest_ResourceType_ResourceType_MIN = ClientDownloadRequest_ResourceType_DOWNLOAD_URL;
const ClientDownloadRequest_ResourceType ClientDownloadRequest_ResourceType_ResourceType_MAX = ClientDownloadRequest_ResourceType_TAB_REDIRECT;
const int ClientDownloadRequest_ResourceType_ResourceType_ARRAYSIZE = ClientDownloadRequest_ResourceType_ResourceType_MAX + 1;

enum ClientDownloadRequest_DownloadType {
  ClientDownloadRequest_DownloadType_WIN_EXECUTABLE = 0,
  ClientDownloadRequest_DownloadType_CHROME_EXTENSION = 1,
  ClientDownloadRequest_DownloadType_ANDROID_APK = 2,
  ClientDownloadRequest_DownloadType_ZIPPED_EXECUTABLE = 3
};
bool ClientDownloadRequest_DownloadType_IsValid(int value);
const ClientDownloadRequest_DownloadType ClientDownloadRequest_DownloadType_DownloadType_MIN = ClientDownloadRequest_DownloadType_WIN_EXECUTABLE;
const ClientDownloadRequest_DownloadType ClientDownloadRequest_DownloadType_DownloadType_MAX = ClientDownloadRequest_DownloadType_ZIPPED_EXECUTABLE;
const int ClientDownloadRequest_DownloadType_DownloadType_ARRAYSIZE = ClientDownloadRequest_DownloadType_DownloadType_MAX + 1;

enum ClientDownloadResponse_Verdict {
  ClientDownloadResponse_Verdict_SAFE = 0,
  ClientDownloadResponse_Verdict_DANGEROUS = 1,
  ClientDownloadResponse_Verdict_UNCOMMON = 2,
  ClientDownloadResponse_Verdict_POTENTIALLY_UNWANTED = 3,
  ClientDownloadResponse_Verdict_DANGEROUS_HOST = 4
};
bool ClientDownloadResponse_Verdict_IsValid(int value);
const ClientDownloadResponse_Verdict ClientDownloadResponse_Verdict_Verdict_MIN = ClientDownloadResponse_Verdict_SAFE;
const ClientDownloadResponse_Verdict ClientDownloadResponse_Verdict_Verdict_MAX = ClientDownloadResponse_Verdict_DANGEROUS_HOST;
const int ClientDownloadResponse_Verdict_Verdict_ARRAYSIZE = ClientDownloadResponse_Verdict_Verdict_MAX + 1;

// ===================================================================

class ClientDownloadRequest_Digests : public ::google::protobuf::MessageLite {
 public:
  ClientDownloadRequest_Digests();
  virtual ~ClientDownloadRequest_Digests();
  
  ClientDownloadRequest_Digests(const ClientDownloadRequest_Digests& from);
  
  inline ClientDownloadRequest_Digests& operator=(const ClientDownloadRequest_Digests& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ClientDownloadRequest_Digests& default_instance();
  
  void Swap(ClientDownloadRequest_Digests* other);
  
  // implements Message ----------------------------------------------
  
  ClientDownloadRequest_Digests* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientDownloadRequest_Digests& from);
  void MergeFrom(const ClientDownloadRequest_Digests& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bytes sha256 = 1;
  inline bool has_sha256() const;
  inline void clear_sha256();
  static const int kSha256FieldNumber = 1;
  inline const ::std::string& sha256() const;
  inline void set_sha256(const ::std::string& value);
  inline void set_sha256(const char* value);
  inline void set_sha256(const void* value, size_t size);
  inline ::std::string* mutable_sha256();
  inline ::std::string* release_sha256();
  
  // optional bytes sha1 = 2;
  inline bool has_sha1() const;
  inline void clear_sha1();
  static const int kSha1FieldNumber = 2;
  inline const ::std::string& sha1() const;
  inline void set_sha1(const ::std::string& value);
  inline void set_sha1(const char* value);
  inline void set_sha1(const void* value, size_t size);
  inline ::std::string* mutable_sha1();
  inline ::std::string* release_sha1();
  
  // optional bytes md5 = 3;
  inline bool has_md5() const;
  inline void clear_md5();
  static const int kMd5FieldNumber = 3;
  inline const ::std::string& md5() const;
  inline void set_md5(const ::std::string& value);
  inline void set_md5(const char* value);
  inline void set_md5(const void* value, size_t size);
  inline ::std::string* mutable_md5();
  inline ::std::string* release_md5();
  
  // @@protoc_insertion_point(class_scope:safe_browsing.ClientDownloadRequest.Digests)
 private:
  inline void set_has_sha256();
  inline void clear_has_sha256();
  inline void set_has_sha1();
  inline void clear_has_sha1();
  inline void set_has_md5();
  inline void clear_has_md5();
  
  ::std::string* sha256_;
  ::std::string* sha1_;
  ::std::string* md5_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_csd_2eproto();
  friend void protobuf_AssignDesc_csd_2eproto();
  friend void protobuf_ShutdownFile_csd_2eproto();
  
  void InitAsDefaultInstance();
  static ClientDownloadRequest_Digests* default_instance_;
};
// -------------------------------------------------------------------

class ClientDownloadRequest_Resource : public ::google::protobuf::MessageLite {
 public:
  ClientDownloadRequest_Resource();
  virtual ~ClientDownloadRequest_Resource();
  
  ClientDownloadRequest_Resource(const ClientDownloadRequest_Resource& from);
  
  inline ClientDownloadRequest_Resource& operator=(const ClientDownloadRequest_Resource& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ClientDownloadRequest_Resource& default_instance();
  
  void Swap(ClientDownloadRequest_Resource* other);
  
  // implements Message ----------------------------------------------
  
  ClientDownloadRequest_Resource* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientDownloadRequest_Resource& from);
  void MergeFrom(const ClientDownloadRequest_Resource& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string url = 1;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 1;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  
  // required .safe_browsing.ClientDownloadRequest.ResourceType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::safe_browsing::ClientDownloadRequest_ResourceType type() const;
  inline void set_type(::safe_browsing::ClientDownloadRequest_ResourceType value);
  
  // optional bytes remote_ip = 3;
  inline bool has_remote_ip() const;
  inline void clear_remote_ip();
  static const int kRemoteIpFieldNumber = 3;
  inline const ::std::string& remote_ip() const;
  inline void set_remote_ip(const ::std::string& value);
  inline void set_remote_ip(const char* value);
  inline void set_remote_ip(const void* value, size_t size);
  inline ::std::string* mutable_remote_ip();
  inline ::std::string* release_remote_ip();
  
  // optional string referrer = 4;
  inline bool has_referrer() const;
  inline void clear_referrer();
  static const int kReferrerFieldNumber = 4;
  inline const ::std::string& referrer() const;
  inline void set_referrer(const ::std::string& value);
  inline void set_referrer(const char* value);
  inline void set_referrer(const char* value, size_t size);
  inline ::std::string* mutable_referrer();
  inline ::std::string* release_referrer();
  
  // @@protoc_insertion_point(class_scope:safe_browsing.ClientDownloadRequest.Resource)
 private:
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_remote_ip();
  inline void clear_has_remote_ip();
  inline void set_has_referrer();
  inline void clear_has_referrer();
  
  ::std::string* url_;
  ::std::string* remote_ip_;
  ::std::string* referrer_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_csd_2eproto();
  friend void protobuf_AssignDesc_csd_2eproto();
  friend void protobuf_ShutdownFile_csd_2eproto();
  
  void InitAsDefaultInstance();
  static ClientDownloadRequest_Resource* default_instance_;
};
// -------------------------------------------------------------------

class ClientDownloadRequest_CertificateChain_Element : public ::google::protobuf::MessageLite {
 public:
  ClientDownloadRequest_CertificateChain_Element();
  virtual ~ClientDownloadRequest_CertificateChain_Element();
  
  ClientDownloadRequest_CertificateChain_Element(const ClientDownloadRequest_CertificateChain_Element& from);
  
  inline ClientDownloadRequest_CertificateChain_Element& operator=(const ClientDownloadRequest_CertificateChain_Element& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ClientDownloadRequest_CertificateChain_Element& default_instance();
  
  void Swap(ClientDownloadRequest_CertificateChain_Element* other);
  
  // implements Message ----------------------------------------------
  
  ClientDownloadRequest_CertificateChain_Element* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientDownloadRequest_CertificateChain_Element& from);
  void MergeFrom(const ClientDownloadRequest_CertificateChain_Element& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bytes certificate = 1;
  inline bool has_certificate() const;
  inline void clear_certificate();
  static const int kCertificateFieldNumber = 1;
  inline const ::std::string& certificate() const;
  inline void set_certificate(const ::std::string& value);
  inline void set_certificate(const char* value);
  inline void set_certificate(const void* value, size_t size);
  inline ::std::string* mutable_certificate();
  inline ::std::string* release_certificate();
  
  // @@protoc_insertion_point(class_scope:safe_browsing.ClientDownloadRequest.CertificateChain.Element)
 private:
  inline void set_has_certificate();
  inline void clear_has_certificate();
  
  ::std::string* certificate_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_csd_2eproto();
  friend void protobuf_AssignDesc_csd_2eproto();
  friend void protobuf_ShutdownFile_csd_2eproto();
  
  void InitAsDefaultInstance();
  static ClientDownloadRequest_CertificateChain_Element* default_instance_;
};
// -------------------------------------------------------------------

class ClientDownloadRequest_CertificateChain : public ::google::protobuf::MessageLite {
 public:
  ClientDownloadRequest_CertificateChain();
  virtual ~ClientDownloadRequest_CertificateChain();
  
  ClientDownloadRequest_CertificateChain(const ClientDownloadRequest_CertificateChain& from);
  
  inline ClientDownloadRequest_CertificateChain& operator=(const ClientDownloadRequest_CertificateChain& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ClientDownloadRequest_CertificateChain& default_instance();
  
  void Swap(ClientDownloadRequest_CertificateChain* other);
  
  // implements Message ----------------------------------------------
  
  ClientDownloadRequest_CertificateChain* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientDownloadRequest_CertificateChain& from);
  void MergeFrom(const ClientDownloadRequest_CertificateChain& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef ClientDownloadRequest_CertificateChain_Element Element;
  
  // accessors -------------------------------------------------------
  
  // repeated .safe_browsing.ClientDownloadRequest.CertificateChain.Element element = 1;
  inline int element_size() const;
  inline void clear_element();
  static const int kElementFieldNumber = 1;
  inline const ::safe_browsing::ClientDownloadRequest_CertificateChain_Element& element(int index) const;
  inline ::safe_browsing::ClientDownloadRequest_CertificateChain_Element* mutable_element(int index);
  inline ::safe_browsing::ClientDownloadRequest_CertificateChain_Element* add_element();
  inline const ::google::protobuf::RepeatedPtrField< ::safe_browsing::ClientDownloadRequest_CertificateChain_Element >&
      element() const;
  inline ::google::protobuf::RepeatedPtrField< ::safe_browsing::ClientDownloadRequest_CertificateChain_Element >*
      mutable_element();
  
  // @@protoc_insertion_point(class_scope:safe_browsing.ClientDownloadRequest.CertificateChain)
 private:
  
  ::google::protobuf::RepeatedPtrField< ::safe_browsing::ClientDownloadRequest_CertificateChain_Element > element_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_csd_2eproto();
  friend void protobuf_AssignDesc_csd_2eproto();
  friend void protobuf_ShutdownFile_csd_2eproto();
  
  void InitAsDefaultInstance();
  static ClientDownloadRequest_CertificateChain* default_instance_;
};
// -------------------------------------------------------------------

class ClientDownloadRequest_SignatureInfo : public ::google::protobuf::MessageLite {
 public:
  ClientDownloadRequest_SignatureInfo();
  virtual ~ClientDownloadRequest_SignatureInfo();
  
  ClientDownloadRequest_SignatureInfo(const ClientDownloadRequest_SignatureInfo& from);
  
  inline ClientDownloadRequest_SignatureInfo& operator=(const ClientDownloadRequest_SignatureInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ClientDownloadRequest_SignatureInfo& default_instance();
  
  void Swap(ClientDownloadRequest_SignatureInfo* other);
  
  // implements Message ----------------------------------------------
  
  ClientDownloadRequest_SignatureInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientDownloadRequest_SignatureInfo& from);
  void MergeFrom(const ClientDownloadRequest_SignatureInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .safe_browsing.ClientDownloadRequest.CertificateChain certificate_chain = 1;
  inline int certificate_chain_size() const;
  inline void clear_certificate_chain();
  static const int kCertificateChainFieldNumber = 1;
  inline const ::safe_browsing::ClientDownloadRequest_CertificateChain& certificate_chain(int index) const;
  inline ::safe_browsing::ClientDownloadRequest_CertificateChain* mutable_certificate_chain(int index);
  inline ::safe_browsing::ClientDownloadRequest_CertificateChain* add_certificate_chain();
  inline const ::google::protobuf::RepeatedPtrField< ::safe_browsing::ClientDownloadRequest_CertificateChain >&
      certificate_chain() const;
  inline ::google::protobuf::RepeatedPtrField< ::safe_browsing::ClientDownloadRequest_CertificateChain >*
      mutable_certificate_chain();
  
  // optional bool trusted = 2;
  inline bool has_trusted() const;
  inline void clear_trusted();
  static const int kTrustedFieldNumber = 2;
  inline bool trusted() const;
  inline void set_trusted(bool value);
  
  // @@protoc_insertion_point(class_scope:safe_browsing.ClientDownloadRequest.SignatureInfo)
 private:
  inline void set_has_trusted();
  inline void clear_has_trusted();
  
  ::google::protobuf::RepeatedPtrField< ::safe_browsing::ClientDownloadRequest_CertificateChain > certificate_chain_;
  bool trusted_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_csd_2eproto();
  friend void protobuf_AssignDesc_csd_2eproto();
  friend void protobuf_ShutdownFile_csd_2eproto();
  
  void InitAsDefaultInstance();
  static ClientDownloadRequest_SignatureInfo* default_instance_;
};
// -------------------------------------------------------------------

class ClientDownloadRequest_PEImageHeaders_DebugData : public ::google::protobuf::MessageLite {
 public:
  ClientDownloadRequest_PEImageHeaders_DebugData();
  virtual ~ClientDownloadRequest_PEImageHeaders_DebugData();
  
  ClientDownloadRequest_PEImageHeaders_DebugData(const ClientDownloadRequest_PEImageHeaders_DebugData& from);
  
  inline ClientDownloadRequest_PEImageHeaders_DebugData& operator=(const ClientDownloadRequest_PEImageHeaders_DebugData& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ClientDownloadRequest_PEImageHeaders_DebugData& default_instance();
  
  void Swap(ClientDownloadRequest_PEImageHeaders_DebugData* other);
  
  // implements Message ----------------------------------------------
  
  ClientDownloadRequest_PEImageHeaders_DebugData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientDownloadRequest_PEImageHeaders_DebugData& from);
  void MergeFrom(const ClientDownloadRequest_PEImageHeaders_DebugData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bytes directory_entry = 1;
  inline bool has_directory_entry() const;
  inline void clear_directory_entry();
  static const int kDirectoryEntryFieldNumber = 1;
  inline const ::std::string& directory_entry() const;
  inline void set_directory_entry(const ::std::string& value);
  inline void set_directory_entry(const char* value);
  inline void set_directory_entry(const void* value, size_t size);
  inline ::std::string* mutable_directory_entry();
  inline ::std::string* release_directory_entry();
  
  // optional bytes raw_data = 2;
  inline bool has_raw_data() const;
  inline void clear_raw_data();
  static const int kRawDataFieldNumber = 2;
  inline const ::std::string& raw_data() const;
  inline void set_raw_data(const ::std::string& value);
  inline void set_raw_data(const char* value);
  inline void set_raw_data(const void* value, size_t size);
  inline ::std::string* mutable_raw_data();
  inline ::std::string* release_raw_data();
  
  // @@protoc_insertion_point(class_scope:safe_browsing.ClientDownloadRequest.PEImageHeaders.DebugData)
 private:
  inline void set_has_directory_entry();
  inline void clear_has_directory_entry();
  inline void set_has_raw_data();
  inline void clear_has_raw_data();
  
  ::std::string* directory_entry_;
  ::std::string* raw_data_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_csd_2eproto();
  friend void protobuf_AssignDesc_csd_2eproto();
  friend void protobuf_ShutdownFile_csd_2eproto();
  
  void InitAsDefaultInstance();
  static ClientDownloadRequest_PEImageHeaders_DebugData* default_instance_;
};
// -------------------------------------------------------------------

class ClientDownloadRequest_PEImageHeaders : public ::google::protobuf::MessageLite {
 public:
  ClientDownloadRequest_PEImageHeaders();
  virtual ~ClientDownloadRequest_PEImageHeaders();
  
  ClientDownloadRequest_PEImageHeaders(const ClientDownloadRequest_PEImageHeaders& from);
  
  inline ClientDownloadRequest_PEImageHeaders& operator=(const ClientDownloadRequest_PEImageHeaders& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ClientDownloadRequest_PEImageHeaders& default_instance();
  
  void Swap(ClientDownloadRequest_PEImageHeaders* other);
  
  // implements Message ----------------------------------------------
  
  ClientDownloadRequest_PEImageHeaders* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientDownloadRequest_PEImageHeaders& from);
  void MergeFrom(const ClientDownloadRequest_PEImageHeaders& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef ClientDownloadRequest_PEImageHeaders_DebugData DebugData;
  
  // accessors -------------------------------------------------------
  
  // optional bytes dos_header = 1;
  inline bool has_dos_header() const;
  inline void clear_dos_header();
  static const int kDosHeaderFieldNumber = 1;
  inline const ::std::string& dos_header() const;
  inline void set_dos_header(const ::std::string& value);
  inline void set_dos_header(const char* value);
  inline void set_dos_header(const void* value, size_t size);
  inline ::std::string* mutable_dos_header();
  inline ::std::string* release_dos_header();
  
  // optional bytes file_header = 2;
  inline bool has_file_header() const;
  inline void clear_file_header();
  static const int kFileHeaderFieldNumber = 2;
  inline const ::std::string& file_header() const;
  inline void set_file_header(const ::std::string& value);
  inline void set_file_header(const char* value);
  inline void set_file_header(const void* value, size_t size);
  inline ::std::string* mutable_file_header();
  inline ::std::string* release_file_header();
  
  // optional bytes optional_headers32 = 3;
  inline bool has_optional_headers32() const;
  inline void clear_optional_headers32();
  static const int kOptionalHeaders32FieldNumber = 3;
  inline const ::std::string& optional_headers32() const;
  inline void set_optional_headers32(const ::std::string& value);
  inline void set_optional_headers32(const char* value);
  inline void set_optional_headers32(const void* value, size_t size);
  inline ::std::string* mutable_optional_headers32();
  inline ::std::string* release_optional_headers32();
  
  // optional bytes optional_headers64 = 4;
  inline bool has_optional_headers64() const;
  inline void clear_optional_headers64();
  static const int kOptionalHeaders64FieldNumber = 4;
  inline const ::std::string& optional_headers64() const;
  inline void set_optional_headers64(const ::std::string& value);
  inline void set_optional_headers64(const char* value);
  inline void set_optional_headers64(const void* value, size_t size);
  inline ::std::string* mutable_optional_headers64();
  inline ::std::string* release_optional_headers64();
  
  // repeated bytes section_header = 5;
  inline int section_header_size() const;
  inline void clear_section_header();
  static const int kSectionHeaderFieldNumber = 5;
  inline const ::std::string& section_header(int index) const;
  inline ::std::string* mutable_section_header(int index);
  inline void set_section_header(int index, const ::std::string& value);
  inline void set_section_header(int index, const char* value);
  inline void set_section_header(int index, const void* value, size_t size);
  inline ::std::string* add_section_header();
  inline void add_section_header(const ::std::string& value);
  inline void add_section_header(const char* value);
  inline void add_section_header(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& section_header() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_section_header();
  
  // optional bytes export_section_data = 6;
  inline bool has_export_section_data() const;
  inline void clear_export_section_data();
  static const int kExportSectionDataFieldNumber = 6;
  inline const ::std::string& export_section_data() const;
  inline void set_export_section_data(const ::std::string& value);
  inline void set_export_section_data(const char* value);
  inline void set_export_section_data(const void* value, size_t size);
  inline ::std::string* mutable_export_section_data();
  inline ::std::string* release_export_section_data();
  
  // repeated .safe_browsing.ClientDownloadRequest.PEImageHeaders.DebugData debug_data = 7;
  inline int debug_data_size() const;
  inline void clear_debug_data();
  static const int kDebugDataFieldNumber = 7;
  inline const ::safe_browsing::ClientDownloadRequest_PEImageHeaders_DebugData& debug_data(int index) const;
  inline ::safe_browsing::ClientDownloadRequest_PEImageHeaders_DebugData* mutable_debug_data(int index);
  inline ::safe_browsing::ClientDownloadRequest_PEImageHeaders_DebugData* add_debug_data();
  inline const ::google::protobuf::RepeatedPtrField< ::safe_browsing::ClientDownloadRequest_PEImageHeaders_DebugData >&
      debug_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::safe_browsing::ClientDownloadRequest_PEImageHeaders_DebugData >*
      mutable_debug_data();
  
  // @@protoc_insertion_point(class_scope:safe_browsing.ClientDownloadRequest.PEImageHeaders)
 private:
  inline void set_has_dos_header();
  inline void clear_has_dos_header();
  inline void set_has_file_header();
  inline void clear_has_file_header();
  inline void set_has_optional_headers32();
  inline void clear_has_optional_headers32();
  inline void set_has_optional_headers64();
  inline void clear_has_optional_headers64();
  inline void set_has_export_section_data();
  inline void clear_has_export_section_data();
  
  ::std::string* dos_header_;
  ::std::string* file_header_;
  ::std::string* optional_headers32_;
  ::std::string* optional_headers64_;
  ::google::protobuf::RepeatedPtrField< ::std::string> section_header_;
  ::std::string* export_section_data_;
  ::google::protobuf::RepeatedPtrField< ::safe_browsing::ClientDownloadRequest_PEImageHeaders_DebugData > debug_data_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_csd_2eproto();
  friend void protobuf_AssignDesc_csd_2eproto();
  friend void protobuf_ShutdownFile_csd_2eproto();
  
  void InitAsDefaultInstance();
  static ClientDownloadRequest_PEImageHeaders* default_instance_;
};
// -------------------------------------------------------------------

class ClientDownloadRequest_ImageHeaders : public ::google::protobuf::MessageLite {
 public:
  ClientDownloadRequest_ImageHeaders();
  virtual ~ClientDownloadRequest_ImageHeaders();
  
  ClientDownloadRequest_ImageHeaders(const ClientDownloadRequest_ImageHeaders& from);
  
  inline ClientDownloadRequest_ImageHeaders& operator=(const ClientDownloadRequest_ImageHeaders& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ClientDownloadRequest_ImageHeaders& default_instance();
  
  void Swap(ClientDownloadRequest_ImageHeaders* other);
  
  // implements Message ----------------------------------------------
  
  ClientDownloadRequest_ImageHeaders* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientDownloadRequest_ImageHeaders& from);
  void MergeFrom(const ClientDownloadRequest_ImageHeaders& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .safe_browsing.ClientDownloadRequest.PEImageHeaders pe_headers = 1;
  inline bool has_pe_headers() const;
  inline void clear_pe_headers();
  static const int kPeHeadersFieldNumber = 1;
  inline const ::safe_browsing::ClientDownloadRequest_PEImageHeaders& pe_headers() const;
  inline ::safe_browsing::ClientDownloadRequest_PEImageHeaders* mutable_pe_headers();
  inline ::safe_browsing::ClientDownloadRequest_PEImageHeaders* release_pe_headers();
  
  // @@protoc_insertion_point(class_scope:safe_browsing.ClientDownloadRequest.ImageHeaders)
 private:
  inline void set_has_pe_headers();
  inline void clear_has_pe_headers();
  
  ::safe_browsing::ClientDownloadRequest_PEImageHeaders* pe_headers_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_csd_2eproto();
  friend void protobuf_AssignDesc_csd_2eproto();
  friend void protobuf_ShutdownFile_csd_2eproto();
  
  void InitAsDefaultInstance();
  static ClientDownloadRequest_ImageHeaders* default_instance_;
};
// -------------------------------------------------------------------

class ClientDownloadRequest : public ::google::protobuf::MessageLite {
 public:
  ClientDownloadRequest();
  virtual ~ClientDownloadRequest();
  
  ClientDownloadRequest(const ClientDownloadRequest& from);
  
  inline ClientDownloadRequest& operator=(const ClientDownloadRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ClientDownloadRequest& default_instance();
  
  void Swap(ClientDownloadRequest* other);
  
  // implements Message ----------------------------------------------
  
  ClientDownloadRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientDownloadRequest& from);
  void MergeFrom(const ClientDownloadRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef ClientDownloadRequest_Digests Digests;
  typedef ClientDownloadRequest_Resource Resource;
  typedef ClientDownloadRequest_CertificateChain CertificateChain;
  typedef ClientDownloadRequest_SignatureInfo SignatureInfo;
  typedef ClientDownloadRequest_PEImageHeaders PEImageHeaders;
  typedef ClientDownloadRequest_ImageHeaders ImageHeaders;
  
  typedef ClientDownloadRequest_ResourceType ResourceType;
  static const ResourceType DOWNLOAD_URL = ClientDownloadRequest_ResourceType_DOWNLOAD_URL;
  static const ResourceType DOWNLOAD_REDIRECT = ClientDownloadRequest_ResourceType_DOWNLOAD_REDIRECT;
  static const ResourceType TAB_URL = ClientDownloadRequest_ResourceType_TAB_URL;
  static const ResourceType TAB_REDIRECT = ClientDownloadRequest_ResourceType_TAB_REDIRECT;
  static inline bool ResourceType_IsValid(int value) {
    return ClientDownloadRequest_ResourceType_IsValid(value);
  }
  static const ResourceType ResourceType_MIN =
    ClientDownloadRequest_ResourceType_ResourceType_MIN;
  static const ResourceType ResourceType_MAX =
    ClientDownloadRequest_ResourceType_ResourceType_MAX;
  static const int ResourceType_ARRAYSIZE =
    ClientDownloadRequest_ResourceType_ResourceType_ARRAYSIZE;
  
  typedef ClientDownloadRequest_DownloadType DownloadType;
  static const DownloadType WIN_EXECUTABLE = ClientDownloadRequest_DownloadType_WIN_EXECUTABLE;
  static const DownloadType CHROME_EXTENSION = ClientDownloadRequest_DownloadType_CHROME_EXTENSION;
  static const DownloadType ANDROID_APK = ClientDownloadRequest_DownloadType_ANDROID_APK;
  static const DownloadType ZIPPED_EXECUTABLE = ClientDownloadRequest_DownloadType_ZIPPED_EXECUTABLE;
  static inline bool DownloadType_IsValid(int value) {
    return ClientDownloadRequest_DownloadType_IsValid(value);
  }
  static const DownloadType DownloadType_MIN =
    ClientDownloadRequest_DownloadType_DownloadType_MIN;
  static const DownloadType DownloadType_MAX =
    ClientDownloadRequest_DownloadType_DownloadType_MAX;
  static const int DownloadType_ARRAYSIZE =
    ClientDownloadRequest_DownloadType_DownloadType_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // required string url = 1;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 1;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  
  // required .safe_browsing.ClientDownloadRequest.Digests digests = 2;
  inline bool has_digests() const;
  inline void clear_digests();
  static const int kDigestsFieldNumber = 2;
  inline const ::safe_browsing::ClientDownloadRequest_Digests& digests() const;
  inline ::safe_browsing::ClientDownloadRequest_Digests* mutable_digests();
  inline ::safe_browsing::ClientDownloadRequest_Digests* release_digests();
  
  // required int64 length = 3;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 3;
  inline ::google::protobuf::int64 length() const;
  inline void set_length(::google::protobuf::int64 value);
  
  // repeated .safe_browsing.ClientDownloadRequest.Resource resources = 4;
  inline int resources_size() const;
  inline void clear_resources();
  static const int kResourcesFieldNumber = 4;
  inline const ::safe_browsing::ClientDownloadRequest_Resource& resources(int index) const;
  inline ::safe_browsing::ClientDownloadRequest_Resource* mutable_resources(int index);
  inline ::safe_browsing::ClientDownloadRequest_Resource* add_resources();
  inline const ::google::protobuf::RepeatedPtrField< ::safe_browsing::ClientDownloadRequest_Resource >&
      resources() const;
  inline ::google::protobuf::RepeatedPtrField< ::safe_browsing::ClientDownloadRequest_Resource >*
      mutable_resources();
  
  // optional .safe_browsing.ClientDownloadRequest.SignatureInfo signature = 5;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 5;
  inline const ::safe_browsing::ClientDownloadRequest_SignatureInfo& signature() const;
  inline ::safe_browsing::ClientDownloadRequest_SignatureInfo* mutable_signature();
  inline ::safe_browsing::ClientDownloadRequest_SignatureInfo* release_signature();
  
  // optional bool user_initiated = 6;
  inline bool has_user_initiated() const;
  inline void clear_user_initiated();
  static const int kUserInitiatedFieldNumber = 6;
  inline bool user_initiated() const;
  inline void set_user_initiated(bool value);
  
  // optional string file_basename = 9;
  inline bool has_file_basename() const;
  inline void clear_file_basename();
  static const int kFileBasenameFieldNumber = 9;
  inline const ::std::string& file_basename() const;
  inline void set_file_basename(const ::std::string& value);
  inline void set_file_basename(const char* value);
  inline void set_file_basename(const char* value, size_t size);
  inline ::std::string* mutable_file_basename();
  inline ::std::string* release_file_basename();
  
  // optional .safe_browsing.ClientDownloadRequest.DownloadType download_type = 10 [default = WIN_EXECUTABLE];
  inline bool has_download_type() const;
  inline void clear_download_type();
  static const int kDownloadTypeFieldNumber = 10;
  inline ::safe_browsing::ClientDownloadRequest_DownloadType download_type() const;
  inline void set_download_type(::safe_browsing::ClientDownloadRequest_DownloadType value);
  
  // optional string locale = 11;
  inline bool has_locale() const;
  inline void clear_locale();
  static const int kLocaleFieldNumber = 11;
  inline const ::std::string& locale() const;
  inline void set_locale(const ::std::string& value);
  inline void set_locale(const char* value);
  inline void set_locale(const char* value, size_t size);
  inline ::std::string* mutable_locale();
  inline ::std::string* release_locale();
  
  // optional .safe_browsing.ClientDownloadRequest.ImageHeaders image_headers = 18;
  inline bool has_image_headers() const;
  inline void clear_image_headers();
  static const int kImageHeadersFieldNumber = 18;
  inline const ::safe_browsing::ClientDownloadRequest_ImageHeaders& image_headers() const;
  inline ::safe_browsing::ClientDownloadRequest_ImageHeaders* mutable_image_headers();
  inline ::safe_browsing::ClientDownloadRequest_ImageHeaders* release_image_headers();
  
  // @@protoc_insertion_point(class_scope:safe_browsing.ClientDownloadRequest)
 private:
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_digests();
  inline void clear_has_digests();
  inline void set_has_length();
  inline void clear_has_length();
  inline void set_has_signature();
  inline void clear_has_signature();
  inline void set_has_user_initiated();
  inline void clear_has_user_initiated();
  inline void set_has_file_basename();
  inline void clear_has_file_basename();
  inline void set_has_download_type();
  inline void clear_has_download_type();
  inline void set_has_locale();
  inline void clear_has_locale();
  inline void set_has_image_headers();
  inline void clear_has_image_headers();
  
  ::std::string* url_;
  ::safe_browsing::ClientDownloadRequest_Digests* digests_;
  ::google::protobuf::int64 length_;
  ::google::protobuf::RepeatedPtrField< ::safe_browsing::ClientDownloadRequest_Resource > resources_;
  ::safe_browsing::ClientDownloadRequest_SignatureInfo* signature_;
  ::std::string* file_basename_;
  bool user_initiated_;
  int download_type_;
  ::std::string* locale_;
  ::safe_browsing::ClientDownloadRequest_ImageHeaders* image_headers_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];
  
  friend void  protobuf_AddDesc_csd_2eproto();
  friend void protobuf_AssignDesc_csd_2eproto();
  friend void protobuf_ShutdownFile_csd_2eproto();
  
  void InitAsDefaultInstance();
  static ClientDownloadRequest* default_instance_;
};
// -------------------------------------------------------------------

class ClientDownloadResponse_MoreInfo : public ::google::protobuf::MessageLite {
 public:
  ClientDownloadResponse_MoreInfo();
  virtual ~ClientDownloadResponse_MoreInfo();
  
  ClientDownloadResponse_MoreInfo(const ClientDownloadResponse_MoreInfo& from);
  
  inline ClientDownloadResponse_MoreInfo& operator=(const ClientDownloadResponse_MoreInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ClientDownloadResponse_MoreInfo& default_instance();
  
  void Swap(ClientDownloadResponse_MoreInfo* other);
  
  // implements Message ----------------------------------------------
  
  ClientDownloadResponse_MoreInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientDownloadResponse_MoreInfo& from);
  void MergeFrom(const ClientDownloadResponse_MoreInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string description = 1;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 1;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  
  // optional string url = 2;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 2;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  
  // @@protoc_insertion_point(class_scope:safe_browsing.ClientDownloadResponse.MoreInfo)
 private:
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_url();
  inline void clear_has_url();
  
  ::std::string* description_;
  ::std::string* url_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_csd_2eproto();
  friend void protobuf_AssignDesc_csd_2eproto();
  friend void protobuf_ShutdownFile_csd_2eproto();
  
  void InitAsDefaultInstance();
  static ClientDownloadResponse_MoreInfo* default_instance_;
};
// -------------------------------------------------------------------

class ClientDownloadResponse : public ::google::protobuf::MessageLite {
 public:
  ClientDownloadResponse();
  virtual ~ClientDownloadResponse();
  
  ClientDownloadResponse(const ClientDownloadResponse& from);
  
  inline ClientDownloadResponse& operator=(const ClientDownloadResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ClientDownloadResponse& default_instance();
  
  void Swap(ClientDownloadResponse* other);
  
  // implements Message ----------------------------------------------
  
  ClientDownloadResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientDownloadResponse& from);
  void MergeFrom(const ClientDownloadResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef ClientDownloadResponse_MoreInfo MoreInfo;
  
  typedef ClientDownloadResponse_Verdict Verdict;
  static const Verdict SAFE = ClientDownloadResponse_Verdict_SAFE;
  static const Verdict DANGEROUS = ClientDownloadResponse_Verdict_DANGEROUS;
  static const Verdict UNCOMMON = ClientDownloadResponse_Verdict_UNCOMMON;
  static const Verdict POTENTIALLY_UNWANTED = ClientDownloadResponse_Verdict_POTENTIALLY_UNWANTED;
  static const Verdict DANGEROUS_HOST = ClientDownloadResponse_Verdict_DANGEROUS_HOST;
  static inline bool Verdict_IsValid(int value) {
    return ClientDownloadResponse_Verdict_IsValid(value);
  }
  static const Verdict Verdict_MIN =
    ClientDownloadResponse_Verdict_Verdict_MIN;
  static const Verdict Verdict_MAX =
    ClientDownloadResponse_Verdict_Verdict_MAX;
  static const int Verdict_ARRAYSIZE =
    ClientDownloadResponse_Verdict_Verdict_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // required .safe_browsing.ClientDownloadResponse.Verdict verdict = 1;
  inline bool has_verdict() const;
  inline void clear_verdict();
  static const int kVerdictFieldNumber = 1;
  inline ::safe_browsing::ClientDownloadResponse_Verdict verdict() const;
  inline void set_verdict(::safe_browsing::ClientDownloadResponse_Verdict value);
  
  // optional .safe_browsing.ClientDownloadResponse.MoreInfo more_info = 2;
  inline bool has_more_info() const;
  inline void clear_more_info();
  static const int kMoreInfoFieldNumber = 2;
  inline const ::safe_browsing::ClientDownloadResponse_MoreInfo& more_info() const;
  inline ::safe_browsing::ClientDownloadResponse_MoreInfo* mutable_more_info();
  inline ::safe_browsing::ClientDownloadResponse_MoreInfo* release_more_info();
  
  // optional bytes token = 3;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 3;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const void* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  
  // @@protoc_insertion_point(class_scope:safe_browsing.ClientDownloadResponse)
 private:
  inline void set_has_verdict();
  inline void clear_has_verdict();
  inline void set_has_more_info();
  inline void clear_has_more_info();
  inline void set_has_token();
  inline void clear_has_token();
  
  ::safe_browsing::ClientDownloadResponse_MoreInfo* more_info_;
  ::std::string* token_;
  int verdict_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_csd_2eproto();
  friend void protobuf_AssignDesc_csd_2eproto();
  friend void protobuf_ShutdownFile_csd_2eproto();
  
  void InitAsDefaultInstance();
  static ClientDownloadResponse* default_instance_;
};
// ===================================================================


// ===================================================================

// ClientDownloadRequest_Digests

// optional bytes sha256 = 1;
inline bool ClientDownloadRequest_Digests::has_sha256() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientDownloadRequest_Digests::set_has_sha256() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientDownloadRequest_Digests::clear_has_sha256() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientDownloadRequest_Digests::clear_sha256() {
  if (sha256_ != &::google::protobuf::internal::kEmptyString) {
    sha256_->clear();
  }
  clear_has_sha256();
}
inline const ::std::string& ClientDownloadRequest_Digests::sha256() const {
  return *sha256_;
}
inline void ClientDownloadRequest_Digests::set_sha256(const ::std::string& value) {
  set_has_sha256();
  if (sha256_ == &::google::protobuf::internal::kEmptyString) {
    sha256_ = new ::std::string;
  }
  sha256_->assign(value);
}
inline void ClientDownloadRequest_Digests::set_sha256(const char* value) {
  set_has_sha256();
  if (sha256_ == &::google::protobuf::internal::kEmptyString) {
    sha256_ = new ::std::string;
  }
  sha256_->assign(value);
}
inline void ClientDownloadRequest_Digests::set_sha256(const void* value, size_t size) {
  set_has_sha256();
  if (sha256_ == &::google::protobuf::internal::kEmptyString) {
    sha256_ = new ::std::string;
  }
  sha256_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientDownloadRequest_Digests::mutable_sha256() {
  set_has_sha256();
  if (sha256_ == &::google::protobuf::internal::kEmptyString) {
    sha256_ = new ::std::string;
  }
  return sha256_;
}
inline ::std::string* ClientDownloadRequest_Digests::release_sha256() {
  clear_has_sha256();
  if (sha256_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sha256_;
    sha256_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes sha1 = 2;
inline bool ClientDownloadRequest_Digests::has_sha1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientDownloadRequest_Digests::set_has_sha1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientDownloadRequest_Digests::clear_has_sha1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientDownloadRequest_Digests::clear_sha1() {
  if (sha1_ != &::google::protobuf::internal::kEmptyString) {
    sha1_->clear();
  }
  clear_has_sha1();
}
inline const ::std::string& ClientDownloadRequest_Digests::sha1() const {
  return *sha1_;
}
inline void ClientDownloadRequest_Digests::set_sha1(const ::std::string& value) {
  set_has_sha1();
  if (sha1_ == &::google::protobuf::internal::kEmptyString) {
    sha1_ = new ::std::string;
  }
  sha1_->assign(value);
}
inline void ClientDownloadRequest_Digests::set_sha1(const char* value) {
  set_has_sha1();
  if (sha1_ == &::google::protobuf::internal::kEmptyString) {
    sha1_ = new ::std::string;
  }
  sha1_->assign(value);
}
inline void ClientDownloadRequest_Digests::set_sha1(const void* value, size_t size) {
  set_has_sha1();
  if (sha1_ == &::google::protobuf::internal::kEmptyString) {
    sha1_ = new ::std::string;
  }
  sha1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientDownloadRequest_Digests::mutable_sha1() {
  set_has_sha1();
  if (sha1_ == &::google::protobuf::internal::kEmptyString) {
    sha1_ = new ::std::string;
  }
  return sha1_;
}
inline ::std::string* ClientDownloadRequest_Digests::release_sha1() {
  clear_has_sha1();
  if (sha1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sha1_;
    sha1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes md5 = 3;
inline bool ClientDownloadRequest_Digests::has_md5() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientDownloadRequest_Digests::set_has_md5() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientDownloadRequest_Digests::clear_has_md5() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientDownloadRequest_Digests::clear_md5() {
  if (md5_ != &::google::protobuf::internal::kEmptyString) {
    md5_->clear();
  }
  clear_has_md5();
}
inline const ::std::string& ClientDownloadRequest_Digests::md5() const {
  return *md5_;
}
inline void ClientDownloadRequest_Digests::set_md5(const ::std::string& value) {
  set_has_md5();
  if (md5_ == &::google::protobuf::internal::kEmptyString) {
    md5_ = new ::std::string;
  }
  md5_->assign(value);
}
inline void ClientDownloadRequest_Digests::set_md5(const char* value) {
  set_has_md5();
  if (md5_ == &::google::protobuf::internal::kEmptyString) {
    md5_ = new ::std::string;
  }
  md5_->assign(value);
}
inline void ClientDownloadRequest_Digests::set_md5(const void* value, size_t size) {
  set_has_md5();
  if (md5_ == &::google::protobuf::internal::kEmptyString) {
    md5_ = new ::std::string;
  }
  md5_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientDownloadRequest_Digests::mutable_md5() {
  set_has_md5();
  if (md5_ == &::google::protobuf::internal::kEmptyString) {
    md5_ = new ::std::string;
  }
  return md5_;
}
inline ::std::string* ClientDownloadRequest_Digests::release_md5() {
  clear_has_md5();
  if (md5_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = md5_;
    md5_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ClientDownloadRequest_Resource

// required string url = 1;
inline bool ClientDownloadRequest_Resource::has_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientDownloadRequest_Resource::set_has_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientDownloadRequest_Resource::clear_has_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientDownloadRequest_Resource::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& ClientDownloadRequest_Resource::url() const {
  return *url_;
}
inline void ClientDownloadRequest_Resource::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void ClientDownloadRequest_Resource::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void ClientDownloadRequest_Resource::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientDownloadRequest_Resource::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* ClientDownloadRequest_Resource::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .safe_browsing.ClientDownloadRequest.ResourceType type = 2;
inline bool ClientDownloadRequest_Resource::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientDownloadRequest_Resource::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientDownloadRequest_Resource::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientDownloadRequest_Resource::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::safe_browsing::ClientDownloadRequest_ResourceType ClientDownloadRequest_Resource::type() const {
  return static_cast< ::safe_browsing::ClientDownloadRequest_ResourceType >(type_);
}
inline void ClientDownloadRequest_Resource::set_type(::safe_browsing::ClientDownloadRequest_ResourceType value) {
  GOOGLE_DCHECK(::safe_browsing::ClientDownloadRequest_ResourceType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional bytes remote_ip = 3;
inline bool ClientDownloadRequest_Resource::has_remote_ip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientDownloadRequest_Resource::set_has_remote_ip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientDownloadRequest_Resource::clear_has_remote_ip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientDownloadRequest_Resource::clear_remote_ip() {
  if (remote_ip_ != &::google::protobuf::internal::kEmptyString) {
    remote_ip_->clear();
  }
  clear_has_remote_ip();
}
inline const ::std::string& ClientDownloadRequest_Resource::remote_ip() const {
  return *remote_ip_;
}
inline void ClientDownloadRequest_Resource::set_remote_ip(const ::std::string& value) {
  set_has_remote_ip();
  if (remote_ip_ == &::google::protobuf::internal::kEmptyString) {
    remote_ip_ = new ::std::string;
  }
  remote_ip_->assign(value);
}
inline void ClientDownloadRequest_Resource::set_remote_ip(const char* value) {
  set_has_remote_ip();
  if (remote_ip_ == &::google::protobuf::internal::kEmptyString) {
    remote_ip_ = new ::std::string;
  }
  remote_ip_->assign(value);
}
inline void ClientDownloadRequest_Resource::set_remote_ip(const void* value, size_t size) {
  set_has_remote_ip();
  if (remote_ip_ == &::google::protobuf::internal::kEmptyString) {
    remote_ip_ = new ::std::string;
  }
  remote_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientDownloadRequest_Resource::mutable_remote_ip() {
  set_has_remote_ip();
  if (remote_ip_ == &::google::protobuf::internal::kEmptyString) {
    remote_ip_ = new ::std::string;
  }
  return remote_ip_;
}
inline ::std::string* ClientDownloadRequest_Resource::release_remote_ip() {
  clear_has_remote_ip();
  if (remote_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = remote_ip_;
    remote_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string referrer = 4;
inline bool ClientDownloadRequest_Resource::has_referrer() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientDownloadRequest_Resource::set_has_referrer() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClientDownloadRequest_Resource::clear_has_referrer() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClientDownloadRequest_Resource::clear_referrer() {
  if (referrer_ != &::google::protobuf::internal::kEmptyString) {
    referrer_->clear();
  }
  clear_has_referrer();
}
inline const ::std::string& ClientDownloadRequest_Resource::referrer() const {
  return *referrer_;
}
inline void ClientDownloadRequest_Resource::set_referrer(const ::std::string& value) {
  set_has_referrer();
  if (referrer_ == &::google::protobuf::internal::kEmptyString) {
    referrer_ = new ::std::string;
  }
  referrer_->assign(value);
}
inline void ClientDownloadRequest_Resource::set_referrer(const char* value) {
  set_has_referrer();
  if (referrer_ == &::google::protobuf::internal::kEmptyString) {
    referrer_ = new ::std::string;
  }
  referrer_->assign(value);
}
inline void ClientDownloadRequest_Resource::set_referrer(const char* value, size_t size) {
  set_has_referrer();
  if (referrer_ == &::google::protobuf::internal::kEmptyString) {
    referrer_ = new ::std::string;
  }
  referrer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientDownloadRequest_Resource::mutable_referrer() {
  set_has_referrer();
  if (referrer_ == &::google::protobuf::internal::kEmptyString) {
    referrer_ = new ::std::string;
  }
  return referrer_;
}
inline ::std::string* ClientDownloadRequest_Resource::release_referrer() {
  clear_has_referrer();
  if (referrer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = referrer_;
    referrer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ClientDownloadRequest_CertificateChain_Element

// optional bytes certificate = 1;
inline bool ClientDownloadRequest_CertificateChain_Element::has_certificate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientDownloadRequest_CertificateChain_Element::set_has_certificate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientDownloadRequest_CertificateChain_Element::clear_has_certificate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientDownloadRequest_CertificateChain_Element::clear_certificate() {
  if (certificate_ != &::google::protobuf::internal::kEmptyString) {
    certificate_->clear();
  }
  clear_has_certificate();
}
inline const ::std::string& ClientDownloadRequest_CertificateChain_Element::certificate() const {
  return *certificate_;
}
inline void ClientDownloadRequest_CertificateChain_Element::set_certificate(const ::std::string& value) {
  set_has_certificate();
  if (certificate_ == &::google::protobuf::internal::kEmptyString) {
    certificate_ = new ::std::string;
  }
  certificate_->assign(value);
}
inline void ClientDownloadRequest_CertificateChain_Element::set_certificate(const char* value) {
  set_has_certificate();
  if (certificate_ == &::google::protobuf::internal::kEmptyString) {
    certificate_ = new ::std::string;
  }
  certificate_->assign(value);
}
inline void ClientDownloadRequest_CertificateChain_Element::set_certificate(const void* value, size_t size) {
  set_has_certificate();
  if (certificate_ == &::google::protobuf::internal::kEmptyString) {
    certificate_ = new ::std::string;
  }
  certificate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientDownloadRequest_CertificateChain_Element::mutable_certificate() {
  set_has_certificate();
  if (certificate_ == &::google::protobuf::internal::kEmptyString) {
    certificate_ = new ::std::string;
  }
  return certificate_;
}
inline ::std::string* ClientDownloadRequest_CertificateChain_Element::release_certificate() {
  clear_has_certificate();
  if (certificate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = certificate_;
    certificate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ClientDownloadRequest_CertificateChain

// repeated .safe_browsing.ClientDownloadRequest.CertificateChain.Element element = 1;
inline int ClientDownloadRequest_CertificateChain::element_size() const {
  return element_.size();
}
inline void ClientDownloadRequest_CertificateChain::clear_element() {
  element_.Clear();
}
inline const ::safe_browsing::ClientDownloadRequest_CertificateChain_Element& ClientDownloadRequest_CertificateChain::element(int index) const {
  return element_.Get(index);
}
inline ::safe_browsing::ClientDownloadRequest_CertificateChain_Element* ClientDownloadRequest_CertificateChain::mutable_element(int index) {
  return element_.Mutable(index);
}
inline ::safe_browsing::ClientDownloadRequest_CertificateChain_Element* ClientDownloadRequest_CertificateChain::add_element() {
  return element_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::safe_browsing::ClientDownloadRequest_CertificateChain_Element >&
ClientDownloadRequest_CertificateChain::element() const {
  return element_;
}
inline ::google::protobuf::RepeatedPtrField< ::safe_browsing::ClientDownloadRequest_CertificateChain_Element >*
ClientDownloadRequest_CertificateChain::mutable_element() {
  return &element_;
}

// -------------------------------------------------------------------

// ClientDownloadRequest_SignatureInfo

// repeated .safe_browsing.ClientDownloadRequest.CertificateChain certificate_chain = 1;
inline int ClientDownloadRequest_SignatureInfo::certificate_chain_size() const {
  return certificate_chain_.size();
}
inline void ClientDownloadRequest_SignatureInfo::clear_certificate_chain() {
  certificate_chain_.Clear();
}
inline const ::safe_browsing::ClientDownloadRequest_CertificateChain& ClientDownloadRequest_SignatureInfo::certificate_chain(int index) const {
  return certificate_chain_.Get(index);
}
inline ::safe_browsing::ClientDownloadRequest_CertificateChain* ClientDownloadRequest_SignatureInfo::mutable_certificate_chain(int index) {
  return certificate_chain_.Mutable(index);
}
inline ::safe_browsing::ClientDownloadRequest_CertificateChain* ClientDownloadRequest_SignatureInfo::add_certificate_chain() {
  return certificate_chain_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::safe_browsing::ClientDownloadRequest_CertificateChain >&
ClientDownloadRequest_SignatureInfo::certificate_chain() const {
  return certificate_chain_;
}
inline ::google::protobuf::RepeatedPtrField< ::safe_browsing::ClientDownloadRequest_CertificateChain >*
ClientDownloadRequest_SignatureInfo::mutable_certificate_chain() {
  return &certificate_chain_;
}

// optional bool trusted = 2;
inline bool ClientDownloadRequest_SignatureInfo::has_trusted() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientDownloadRequest_SignatureInfo::set_has_trusted() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientDownloadRequest_SignatureInfo::clear_has_trusted() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientDownloadRequest_SignatureInfo::clear_trusted() {
  trusted_ = false;
  clear_has_trusted();
}
inline bool ClientDownloadRequest_SignatureInfo::trusted() const {
  return trusted_;
}
inline void ClientDownloadRequest_SignatureInfo::set_trusted(bool value) {
  set_has_trusted();
  trusted_ = value;
}

// -------------------------------------------------------------------

// ClientDownloadRequest_PEImageHeaders_DebugData

// optional bytes directory_entry = 1;
inline bool ClientDownloadRequest_PEImageHeaders_DebugData::has_directory_entry() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientDownloadRequest_PEImageHeaders_DebugData::set_has_directory_entry() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientDownloadRequest_PEImageHeaders_DebugData::clear_has_directory_entry() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientDownloadRequest_PEImageHeaders_DebugData::clear_directory_entry() {
  if (directory_entry_ != &::google::protobuf::internal::kEmptyString) {
    directory_entry_->clear();
  }
  clear_has_directory_entry();
}
inline const ::std::string& ClientDownloadRequest_PEImageHeaders_DebugData::directory_entry() const {
  return *directory_entry_;
}
inline void ClientDownloadRequest_PEImageHeaders_DebugData::set_directory_entry(const ::std::string& value) {
  set_has_directory_entry();
  if (directory_entry_ == &::google::protobuf::internal::kEmptyString) {
    directory_entry_ = new ::std::string;
  }
  directory_entry_->assign(value);
}
inline void ClientDownloadRequest_PEImageHeaders_DebugData::set_directory_entry(const char* value) {
  set_has_directory_entry();
  if (directory_entry_ == &::google::protobuf::internal::kEmptyString) {
    directory_entry_ = new ::std::string;
  }
  directory_entry_->assign(value);
}
inline void ClientDownloadRequest_PEImageHeaders_DebugData::set_directory_entry(const void* value, size_t size) {
  set_has_directory_entry();
  if (directory_entry_ == &::google::protobuf::internal::kEmptyString) {
    directory_entry_ = new ::std::string;
  }
  directory_entry_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientDownloadRequest_PEImageHeaders_DebugData::mutable_directory_entry() {
  set_has_directory_entry();
  if (directory_entry_ == &::google::protobuf::internal::kEmptyString) {
    directory_entry_ = new ::std::string;
  }
  return directory_entry_;
}
inline ::std::string* ClientDownloadRequest_PEImageHeaders_DebugData::release_directory_entry() {
  clear_has_directory_entry();
  if (directory_entry_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = directory_entry_;
    directory_entry_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes raw_data = 2;
inline bool ClientDownloadRequest_PEImageHeaders_DebugData::has_raw_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientDownloadRequest_PEImageHeaders_DebugData::set_has_raw_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientDownloadRequest_PEImageHeaders_DebugData::clear_has_raw_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientDownloadRequest_PEImageHeaders_DebugData::clear_raw_data() {
  if (raw_data_ != &::google::protobuf::internal::kEmptyString) {
    raw_data_->clear();
  }
  clear_has_raw_data();
}
inline const ::std::string& ClientDownloadRequest_PEImageHeaders_DebugData::raw_data() const {
  return *raw_data_;
}
inline void ClientDownloadRequest_PEImageHeaders_DebugData::set_raw_data(const ::std::string& value) {
  set_has_raw_data();
  if (raw_data_ == &::google::protobuf::internal::kEmptyString) {
    raw_data_ = new ::std::string;
  }
  raw_data_->assign(value);
}
inline void ClientDownloadRequest_PEImageHeaders_DebugData::set_raw_data(const char* value) {
  set_has_raw_data();
  if (raw_data_ == &::google::protobuf::internal::kEmptyString) {
    raw_data_ = new ::std::string;
  }
  raw_data_->assign(value);
}
inline void ClientDownloadRequest_PEImageHeaders_DebugData::set_raw_data(const void* value, size_t size) {
  set_has_raw_data();
  if (raw_data_ == &::google::protobuf::internal::kEmptyString) {
    raw_data_ = new ::std::string;
  }
  raw_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientDownloadRequest_PEImageHeaders_DebugData::mutable_raw_data() {
  set_has_raw_data();
  if (raw_data_ == &::google::protobuf::internal::kEmptyString) {
    raw_data_ = new ::std::string;
  }
  return raw_data_;
}
inline ::std::string* ClientDownloadRequest_PEImageHeaders_DebugData::release_raw_data() {
  clear_has_raw_data();
  if (raw_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = raw_data_;
    raw_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ClientDownloadRequest_PEImageHeaders

// optional bytes dos_header = 1;
inline bool ClientDownloadRequest_PEImageHeaders::has_dos_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientDownloadRequest_PEImageHeaders::set_has_dos_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientDownloadRequest_PEImageHeaders::clear_has_dos_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientDownloadRequest_PEImageHeaders::clear_dos_header() {
  if (dos_header_ != &::google::protobuf::internal::kEmptyString) {
    dos_header_->clear();
  }
  clear_has_dos_header();
}
inline const ::std::string& ClientDownloadRequest_PEImageHeaders::dos_header() const {
  return *dos_header_;
}
inline void ClientDownloadRequest_PEImageHeaders::set_dos_header(const ::std::string& value) {
  set_has_dos_header();
  if (dos_header_ == &::google::protobuf::internal::kEmptyString) {
    dos_header_ = new ::std::string;
  }
  dos_header_->assign(value);
}
inline void ClientDownloadRequest_PEImageHeaders::set_dos_header(const char* value) {
  set_has_dos_header();
  if (dos_header_ == &::google::protobuf::internal::kEmptyString) {
    dos_header_ = new ::std::string;
  }
  dos_header_->assign(value);
}
inline void ClientDownloadRequest_PEImageHeaders::set_dos_header(const void* value, size_t size) {
  set_has_dos_header();
  if (dos_header_ == &::google::protobuf::internal::kEmptyString) {
    dos_header_ = new ::std::string;
  }
  dos_header_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientDownloadRequest_PEImageHeaders::mutable_dos_header() {
  set_has_dos_header();
  if (dos_header_ == &::google::protobuf::internal::kEmptyString) {
    dos_header_ = new ::std::string;
  }
  return dos_header_;
}
inline ::std::string* ClientDownloadRequest_PEImageHeaders::release_dos_header() {
  clear_has_dos_header();
  if (dos_header_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dos_header_;
    dos_header_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes file_header = 2;
inline bool ClientDownloadRequest_PEImageHeaders::has_file_header() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientDownloadRequest_PEImageHeaders::set_has_file_header() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientDownloadRequest_PEImageHeaders::clear_has_file_header() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientDownloadRequest_PEImageHeaders::clear_file_header() {
  if (file_header_ != &::google::protobuf::internal::kEmptyString) {
    file_header_->clear();
  }
  clear_has_file_header();
}
inline const ::std::string& ClientDownloadRequest_PEImageHeaders::file_header() const {
  return *file_header_;
}
inline void ClientDownloadRequest_PEImageHeaders::set_file_header(const ::std::string& value) {
  set_has_file_header();
  if (file_header_ == &::google::protobuf::internal::kEmptyString) {
    file_header_ = new ::std::string;
  }
  file_header_->assign(value);
}
inline void ClientDownloadRequest_PEImageHeaders::set_file_header(const char* value) {
  set_has_file_header();
  if (file_header_ == &::google::protobuf::internal::kEmptyString) {
    file_header_ = new ::std::string;
  }
  file_header_->assign(value);
}
inline void ClientDownloadRequest_PEImageHeaders::set_file_header(const void* value, size_t size) {
  set_has_file_header();
  if (file_header_ == &::google::protobuf::internal::kEmptyString) {
    file_header_ = new ::std::string;
  }
  file_header_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientDownloadRequest_PEImageHeaders::mutable_file_header() {
  set_has_file_header();
  if (file_header_ == &::google::protobuf::internal::kEmptyString) {
    file_header_ = new ::std::string;
  }
  return file_header_;
}
inline ::std::string* ClientDownloadRequest_PEImageHeaders::release_file_header() {
  clear_has_file_header();
  if (file_header_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_header_;
    file_header_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes optional_headers32 = 3;
inline bool ClientDownloadRequest_PEImageHeaders::has_optional_headers32() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientDownloadRequest_PEImageHeaders::set_has_optional_headers32() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientDownloadRequest_PEImageHeaders::clear_has_optional_headers32() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientDownloadRequest_PEImageHeaders::clear_optional_headers32() {
  if (optional_headers32_ != &::google::protobuf::internal::kEmptyString) {
    optional_headers32_->clear();
  }
  clear_has_optional_headers32();
}
inline const ::std::string& ClientDownloadRequest_PEImageHeaders::optional_headers32() const {
  return *optional_headers32_;
}
inline void ClientDownloadRequest_PEImageHeaders::set_optional_headers32(const ::std::string& value) {
  set_has_optional_headers32();
  if (optional_headers32_ == &::google::protobuf::internal::kEmptyString) {
    optional_headers32_ = new ::std::string;
  }
  optional_headers32_->assign(value);
}
inline void ClientDownloadRequest_PEImageHeaders::set_optional_headers32(const char* value) {
  set_has_optional_headers32();
  if (optional_headers32_ == &::google::protobuf::internal::kEmptyString) {
    optional_headers32_ = new ::std::string;
  }
  optional_headers32_->assign(value);
}
inline void ClientDownloadRequest_PEImageHeaders::set_optional_headers32(const void* value, size_t size) {
  set_has_optional_headers32();
  if (optional_headers32_ == &::google::protobuf::internal::kEmptyString) {
    optional_headers32_ = new ::std::string;
  }
  optional_headers32_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientDownloadRequest_PEImageHeaders::mutable_optional_headers32() {
  set_has_optional_headers32();
  if (optional_headers32_ == &::google::protobuf::internal::kEmptyString) {
    optional_headers32_ = new ::std::string;
  }
  return optional_headers32_;
}
inline ::std::string* ClientDownloadRequest_PEImageHeaders::release_optional_headers32() {
  clear_has_optional_headers32();
  if (optional_headers32_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = optional_headers32_;
    optional_headers32_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes optional_headers64 = 4;
inline bool ClientDownloadRequest_PEImageHeaders::has_optional_headers64() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientDownloadRequest_PEImageHeaders::set_has_optional_headers64() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClientDownloadRequest_PEImageHeaders::clear_has_optional_headers64() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClientDownloadRequest_PEImageHeaders::clear_optional_headers64() {
  if (optional_headers64_ != &::google::protobuf::internal::kEmptyString) {
    optional_headers64_->clear();
  }
  clear_has_optional_headers64();
}
inline const ::std::string& ClientDownloadRequest_PEImageHeaders::optional_headers64() const {
  return *optional_headers64_;
}
inline void ClientDownloadRequest_PEImageHeaders::set_optional_headers64(const ::std::string& value) {
  set_has_optional_headers64();
  if (optional_headers64_ == &::google::protobuf::internal::kEmptyString) {
    optional_headers64_ = new ::std::string;
  }
  optional_headers64_->assign(value);
}
inline void ClientDownloadRequest_PEImageHeaders::set_optional_headers64(const char* value) {
  set_has_optional_headers64();
  if (optional_headers64_ == &::google::protobuf::internal::kEmptyString) {
    optional_headers64_ = new ::std::string;
  }
  optional_headers64_->assign(value);
}
inline void ClientDownloadRequest_PEImageHeaders::set_optional_headers64(const void* value, size_t size) {
  set_has_optional_headers64();
  if (optional_headers64_ == &::google::protobuf::internal::kEmptyString) {
    optional_headers64_ = new ::std::string;
  }
  optional_headers64_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientDownloadRequest_PEImageHeaders::mutable_optional_headers64() {
  set_has_optional_headers64();
  if (optional_headers64_ == &::google::protobuf::internal::kEmptyString) {
    optional_headers64_ = new ::std::string;
  }
  return optional_headers64_;
}
inline ::std::string* ClientDownloadRequest_PEImageHeaders::release_optional_headers64() {
  clear_has_optional_headers64();
  if (optional_headers64_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = optional_headers64_;
    optional_headers64_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated bytes section_header = 5;
inline int ClientDownloadRequest_PEImageHeaders::section_header_size() const {
  return section_header_.size();
}
inline void ClientDownloadRequest_PEImageHeaders::clear_section_header() {
  section_header_.Clear();
}
inline const ::std::string& ClientDownloadRequest_PEImageHeaders::section_header(int index) const {
  return section_header_.Get(index);
}
inline ::std::string* ClientDownloadRequest_PEImageHeaders::mutable_section_header(int index) {
  return section_header_.Mutable(index);
}
inline void ClientDownloadRequest_PEImageHeaders::set_section_header(int index, const ::std::string& value) {
  section_header_.Mutable(index)->assign(value);
}
inline void ClientDownloadRequest_PEImageHeaders::set_section_header(int index, const char* value) {
  section_header_.Mutable(index)->assign(value);
}
inline void ClientDownloadRequest_PEImageHeaders::set_section_header(int index, const void* value, size_t size) {
  section_header_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientDownloadRequest_PEImageHeaders::add_section_header() {
  return section_header_.Add();
}
inline void ClientDownloadRequest_PEImageHeaders::add_section_header(const ::std::string& value) {
  section_header_.Add()->assign(value);
}
inline void ClientDownloadRequest_PEImageHeaders::add_section_header(const char* value) {
  section_header_.Add()->assign(value);
}
inline void ClientDownloadRequest_PEImageHeaders::add_section_header(const void* value, size_t size) {
  section_header_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ClientDownloadRequest_PEImageHeaders::section_header() const {
  return section_header_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ClientDownloadRequest_PEImageHeaders::mutable_section_header() {
  return &section_header_;
}

// optional bytes export_section_data = 6;
inline bool ClientDownloadRequest_PEImageHeaders::has_export_section_data() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClientDownloadRequest_PEImageHeaders::set_has_export_section_data() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClientDownloadRequest_PEImageHeaders::clear_has_export_section_data() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClientDownloadRequest_PEImageHeaders::clear_export_section_data() {
  if (export_section_data_ != &::google::protobuf::internal::kEmptyString) {
    export_section_data_->clear();
  }
  clear_has_export_section_data();
}
inline const ::std::string& ClientDownloadRequest_PEImageHeaders::export_section_data() const {
  return *export_section_data_;
}
inline void ClientDownloadRequest_PEImageHeaders::set_export_section_data(const ::std::string& value) {
  set_has_export_section_data();
  if (export_section_data_ == &::google::protobuf::internal::kEmptyString) {
    export_section_data_ = new ::std::string;
  }
  export_section_data_->assign(value);
}
inline void ClientDownloadRequest_PEImageHeaders::set_export_section_data(const char* value) {
  set_has_export_section_data();
  if (export_section_data_ == &::google::protobuf::internal::kEmptyString) {
    export_section_data_ = new ::std::string;
  }
  export_section_data_->assign(value);
}
inline void ClientDownloadRequest_PEImageHeaders::set_export_section_data(const void* value, size_t size) {
  set_has_export_section_data();
  if (export_section_data_ == &::google::protobuf::internal::kEmptyString) {
    export_section_data_ = new ::std::string;
  }
  export_section_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientDownloadRequest_PEImageHeaders::mutable_export_section_data() {
  set_has_export_section_data();
  if (export_section_data_ == &::google::protobuf::internal::kEmptyString) {
    export_section_data_ = new ::std::string;
  }
  return export_section_data_;
}
inline ::std::string* ClientDownloadRequest_PEImageHeaders::release_export_section_data() {
  clear_has_export_section_data();
  if (export_section_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = export_section_data_;
    export_section_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .safe_browsing.ClientDownloadRequest.PEImageHeaders.DebugData debug_data = 7;
inline int ClientDownloadRequest_PEImageHeaders::debug_data_size() const {
  return debug_data_.size();
}
inline void ClientDownloadRequest_PEImageHeaders::clear_debug_data() {
  debug_data_.Clear();
}
inline const ::safe_browsing::ClientDownloadRequest_PEImageHeaders_DebugData& ClientDownloadRequest_PEImageHeaders::debug_data(int index) const {
  return debug_data_.Get(index);
}
inline ::safe_browsing::ClientDownloadRequest_PEImageHeaders_DebugData* ClientDownloadRequest_PEImageHeaders::mutable_debug_data(int index) {
  return debug_data_.Mutable(index);
}
inline ::safe_browsing::ClientDownloadRequest_PEImageHeaders_DebugData* ClientDownloadRequest_PEImageHeaders::add_debug_data() {
  return debug_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::safe_browsing::ClientDownloadRequest_PEImageHeaders_DebugData >&
ClientDownloadRequest_PEImageHeaders::debug_data() const {
  return debug_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::safe_browsing::ClientDownloadRequest_PEImageHeaders_DebugData >*
ClientDownloadRequest_PEImageHeaders::mutable_debug_data() {
  return &debug_data_;
}

// -------------------------------------------------------------------

// ClientDownloadRequest_ImageHeaders

// optional .safe_browsing.ClientDownloadRequest.PEImageHeaders pe_headers = 1;
inline bool ClientDownloadRequest_ImageHeaders::has_pe_headers() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientDownloadRequest_ImageHeaders::set_has_pe_headers() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientDownloadRequest_ImageHeaders::clear_has_pe_headers() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientDownloadRequest_ImageHeaders::clear_pe_headers() {
  if (pe_headers_ != NULL) pe_headers_->::safe_browsing::ClientDownloadRequest_PEImageHeaders::Clear();
  clear_has_pe_headers();
}
inline const ::safe_browsing::ClientDownloadRequest_PEImageHeaders& ClientDownloadRequest_ImageHeaders::pe_headers() const {
  return pe_headers_ != NULL ? *pe_headers_ : *default_instance_->pe_headers_;
}
inline ::safe_browsing::ClientDownloadRequest_PEImageHeaders* ClientDownloadRequest_ImageHeaders::mutable_pe_headers() {
  set_has_pe_headers();
  if (pe_headers_ == NULL) pe_headers_ = new ::safe_browsing::ClientDownloadRequest_PEImageHeaders;
  return pe_headers_;
}
inline ::safe_browsing::ClientDownloadRequest_PEImageHeaders* ClientDownloadRequest_ImageHeaders::release_pe_headers() {
  clear_has_pe_headers();
  ::safe_browsing::ClientDownloadRequest_PEImageHeaders* temp = pe_headers_;
  pe_headers_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// ClientDownloadRequest

// required string url = 1;
inline bool ClientDownloadRequest::has_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientDownloadRequest::set_has_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientDownloadRequest::clear_has_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientDownloadRequest::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& ClientDownloadRequest::url() const {
  return *url_;
}
inline void ClientDownloadRequest::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void ClientDownloadRequest::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void ClientDownloadRequest::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientDownloadRequest::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* ClientDownloadRequest::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .safe_browsing.ClientDownloadRequest.Digests digests = 2;
inline bool ClientDownloadRequest::has_digests() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientDownloadRequest::set_has_digests() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientDownloadRequest::clear_has_digests() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientDownloadRequest::clear_digests() {
  if (digests_ != NULL) digests_->::safe_browsing::ClientDownloadRequest_Digests::Clear();
  clear_has_digests();
}
inline const ::safe_browsing::ClientDownloadRequest_Digests& ClientDownloadRequest::digests() const {
  return digests_ != NULL ? *digests_ : *default_instance_->digests_;
}
inline ::safe_browsing::ClientDownloadRequest_Digests* ClientDownloadRequest::mutable_digests() {
  set_has_digests();
  if (digests_ == NULL) digests_ = new ::safe_browsing::ClientDownloadRequest_Digests;
  return digests_;
}
inline ::safe_browsing::ClientDownloadRequest_Digests* ClientDownloadRequest::release_digests() {
  clear_has_digests();
  ::safe_browsing::ClientDownloadRequest_Digests* temp = digests_;
  digests_ = NULL;
  return temp;
}

// required int64 length = 3;
inline bool ClientDownloadRequest::has_length() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientDownloadRequest::set_has_length() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientDownloadRequest::clear_has_length() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientDownloadRequest::clear_length() {
  length_ = GOOGLE_LONGLONG(0);
  clear_has_length();
}
inline ::google::protobuf::int64 ClientDownloadRequest::length() const {
  return length_;
}
inline void ClientDownloadRequest::set_length(::google::protobuf::int64 value) {
  set_has_length();
  length_ = value;
}

// repeated .safe_browsing.ClientDownloadRequest.Resource resources = 4;
inline int ClientDownloadRequest::resources_size() const {
  return resources_.size();
}
inline void ClientDownloadRequest::clear_resources() {
  resources_.Clear();
}
inline const ::safe_browsing::ClientDownloadRequest_Resource& ClientDownloadRequest::resources(int index) const {
  return resources_.Get(index);
}
inline ::safe_browsing::ClientDownloadRequest_Resource* ClientDownloadRequest::mutable_resources(int index) {
  return resources_.Mutable(index);
}
inline ::safe_browsing::ClientDownloadRequest_Resource* ClientDownloadRequest::add_resources() {
  return resources_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::safe_browsing::ClientDownloadRequest_Resource >&
ClientDownloadRequest::resources() const {
  return resources_;
}
inline ::google::protobuf::RepeatedPtrField< ::safe_browsing::ClientDownloadRequest_Resource >*
ClientDownloadRequest::mutable_resources() {
  return &resources_;
}

// optional .safe_browsing.ClientDownloadRequest.SignatureInfo signature = 5;
inline bool ClientDownloadRequest::has_signature() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClientDownloadRequest::set_has_signature() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClientDownloadRequest::clear_has_signature() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClientDownloadRequest::clear_signature() {
  if (signature_ != NULL) signature_->::safe_browsing::ClientDownloadRequest_SignatureInfo::Clear();
  clear_has_signature();
}
inline const ::safe_browsing::ClientDownloadRequest_SignatureInfo& ClientDownloadRequest::signature() const {
  return signature_ != NULL ? *signature_ : *default_instance_->signature_;
}
inline ::safe_browsing::ClientDownloadRequest_SignatureInfo* ClientDownloadRequest::mutable_signature() {
  set_has_signature();
  if (signature_ == NULL) signature_ = new ::safe_browsing::ClientDownloadRequest_SignatureInfo;
  return signature_;
}
inline ::safe_browsing::ClientDownloadRequest_SignatureInfo* ClientDownloadRequest::release_signature() {
  clear_has_signature();
  ::safe_browsing::ClientDownloadRequest_SignatureInfo* temp = signature_;
  signature_ = NULL;
  return temp;
}

// optional bool user_initiated = 6;
inline bool ClientDownloadRequest::has_user_initiated() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClientDownloadRequest::set_has_user_initiated() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClientDownloadRequest::clear_has_user_initiated() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClientDownloadRequest::clear_user_initiated() {
  user_initiated_ = false;
  clear_has_user_initiated();
}
inline bool ClientDownloadRequest::user_initiated() const {
  return user_initiated_;
}
inline void ClientDownloadRequest::set_user_initiated(bool value) {
  set_has_user_initiated();
  user_initiated_ = value;
}

// optional string file_basename = 9;
inline bool ClientDownloadRequest::has_file_basename() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ClientDownloadRequest::set_has_file_basename() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ClientDownloadRequest::clear_has_file_basename() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ClientDownloadRequest::clear_file_basename() {
  if (file_basename_ != &::google::protobuf::internal::kEmptyString) {
    file_basename_->clear();
  }
  clear_has_file_basename();
}
inline const ::std::string& ClientDownloadRequest::file_basename() const {
  return *file_basename_;
}
inline void ClientDownloadRequest::set_file_basename(const ::std::string& value) {
  set_has_file_basename();
  if (file_basename_ == &::google::protobuf::internal::kEmptyString) {
    file_basename_ = new ::std::string;
  }
  file_basename_->assign(value);
}
inline void ClientDownloadRequest::set_file_basename(const char* value) {
  set_has_file_basename();
  if (file_basename_ == &::google::protobuf::internal::kEmptyString) {
    file_basename_ = new ::std::string;
  }
  file_basename_->assign(value);
}
inline void ClientDownloadRequest::set_file_basename(const char* value, size_t size) {
  set_has_file_basename();
  if (file_basename_ == &::google::protobuf::internal::kEmptyString) {
    file_basename_ = new ::std::string;
  }
  file_basename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientDownloadRequest::mutable_file_basename() {
  set_has_file_basename();
  if (file_basename_ == &::google::protobuf::internal::kEmptyString) {
    file_basename_ = new ::std::string;
  }
  return file_basename_;
}
inline ::std::string* ClientDownloadRequest::release_file_basename() {
  clear_has_file_basename();
  if (file_basename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_basename_;
    file_basename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .safe_browsing.ClientDownloadRequest.DownloadType download_type = 10 [default = WIN_EXECUTABLE];
inline bool ClientDownloadRequest::has_download_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ClientDownloadRequest::set_has_download_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ClientDownloadRequest::clear_has_download_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ClientDownloadRequest::clear_download_type() {
  download_type_ = 0;
  clear_has_download_type();
}
inline ::safe_browsing::ClientDownloadRequest_DownloadType ClientDownloadRequest::download_type() const {
  return static_cast< ::safe_browsing::ClientDownloadRequest_DownloadType >(download_type_);
}
inline void ClientDownloadRequest::set_download_type(::safe_browsing::ClientDownloadRequest_DownloadType value) {
  GOOGLE_DCHECK(::safe_browsing::ClientDownloadRequest_DownloadType_IsValid(value));
  set_has_download_type();
  download_type_ = value;
}

// optional string locale = 11;
inline bool ClientDownloadRequest::has_locale() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ClientDownloadRequest::set_has_locale() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ClientDownloadRequest::clear_has_locale() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ClientDownloadRequest::clear_locale() {
  if (locale_ != &::google::protobuf::internal::kEmptyString) {
    locale_->clear();
  }
  clear_has_locale();
}
inline const ::std::string& ClientDownloadRequest::locale() const {
  return *locale_;
}
inline void ClientDownloadRequest::set_locale(const ::std::string& value) {
  set_has_locale();
  if (locale_ == &::google::protobuf::internal::kEmptyString) {
    locale_ = new ::std::string;
  }
  locale_->assign(value);
}
inline void ClientDownloadRequest::set_locale(const char* value) {
  set_has_locale();
  if (locale_ == &::google::protobuf::internal::kEmptyString) {
    locale_ = new ::std::string;
  }
  locale_->assign(value);
}
inline void ClientDownloadRequest::set_locale(const char* value, size_t size) {
  set_has_locale();
  if (locale_ == &::google::protobuf::internal::kEmptyString) {
    locale_ = new ::std::string;
  }
  locale_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientDownloadRequest::mutable_locale() {
  set_has_locale();
  if (locale_ == &::google::protobuf::internal::kEmptyString) {
    locale_ = new ::std::string;
  }
  return locale_;
}
inline ::std::string* ClientDownloadRequest::release_locale() {
  clear_has_locale();
  if (locale_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = locale_;
    locale_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .safe_browsing.ClientDownloadRequest.ImageHeaders image_headers = 18;
inline bool ClientDownloadRequest::has_image_headers() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ClientDownloadRequest::set_has_image_headers() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ClientDownloadRequest::clear_has_image_headers() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ClientDownloadRequest::clear_image_headers() {
  if (image_headers_ != NULL) image_headers_->::safe_browsing::ClientDownloadRequest_ImageHeaders::Clear();
  clear_has_image_headers();
}
inline const ::safe_browsing::ClientDownloadRequest_ImageHeaders& ClientDownloadRequest::image_headers() const {
  return image_headers_ != NULL ? *image_headers_ : *default_instance_->image_headers_;
}
inline ::safe_browsing::ClientDownloadRequest_ImageHeaders* ClientDownloadRequest::mutable_image_headers() {
  set_has_image_headers();
  if (image_headers_ == NULL) image_headers_ = new ::safe_browsing::ClientDownloadRequest_ImageHeaders;
  return image_headers_;
}
inline ::safe_browsing::ClientDownloadRequest_ImageHeaders* ClientDownloadRequest::release_image_headers() {
  clear_has_image_headers();
  ::safe_browsing::ClientDownloadRequest_ImageHeaders* temp = image_headers_;
  image_headers_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// ClientDownloadResponse_MoreInfo

// optional string description = 1;
inline bool ClientDownloadResponse_MoreInfo::has_description() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientDownloadResponse_MoreInfo::set_has_description() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientDownloadResponse_MoreInfo::clear_has_description() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientDownloadResponse_MoreInfo::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& ClientDownloadResponse_MoreInfo::description() const {
  return *description_;
}
inline void ClientDownloadResponse_MoreInfo::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void ClientDownloadResponse_MoreInfo::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void ClientDownloadResponse_MoreInfo::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientDownloadResponse_MoreInfo::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* ClientDownloadResponse_MoreInfo::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string url = 2;
inline bool ClientDownloadResponse_MoreInfo::has_url() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientDownloadResponse_MoreInfo::set_has_url() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientDownloadResponse_MoreInfo::clear_has_url() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientDownloadResponse_MoreInfo::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& ClientDownloadResponse_MoreInfo::url() const {
  return *url_;
}
inline void ClientDownloadResponse_MoreInfo::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void ClientDownloadResponse_MoreInfo::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void ClientDownloadResponse_MoreInfo::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientDownloadResponse_MoreInfo::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* ClientDownloadResponse_MoreInfo::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ClientDownloadResponse

// required .safe_browsing.ClientDownloadResponse.Verdict verdict = 1;
inline bool ClientDownloadResponse::has_verdict() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientDownloadResponse::set_has_verdict() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientDownloadResponse::clear_has_verdict() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientDownloadResponse::clear_verdict() {
  verdict_ = 0;
  clear_has_verdict();
}
inline ::safe_browsing::ClientDownloadResponse_Verdict ClientDownloadResponse::verdict() const {
  return static_cast< ::safe_browsing::ClientDownloadResponse_Verdict >(verdict_);
}
inline void ClientDownloadResponse::set_verdict(::safe_browsing::ClientDownloadResponse_Verdict value) {
  GOOGLE_DCHECK(::safe_browsing::ClientDownloadResponse_Verdict_IsValid(value));
  set_has_verdict();
  verdict_ = value;
}

// optional .safe_browsing.ClientDownloadResponse.MoreInfo more_info = 2;
inline bool ClientDownloadResponse::has_more_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientDownloadResponse::set_has_more_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientDownloadResponse::clear_has_more_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientDownloadResponse::clear_more_info() {
  if (more_info_ != NULL) more_info_->::safe_browsing::ClientDownloadResponse_MoreInfo::Clear();
  clear_has_more_info();
}
inline const ::safe_browsing::ClientDownloadResponse_MoreInfo& ClientDownloadResponse::more_info() const {
  return more_info_ != NULL ? *more_info_ : *default_instance_->more_info_;
}
inline ::safe_browsing::ClientDownloadResponse_MoreInfo* ClientDownloadResponse::mutable_more_info() {
  set_has_more_info();
  if (more_info_ == NULL) more_info_ = new ::safe_browsing::ClientDownloadResponse_MoreInfo;
  return more_info_;
}
inline ::safe_browsing::ClientDownloadResponse_MoreInfo* ClientDownloadResponse::release_more_info() {
  clear_has_more_info();
  ::safe_browsing::ClientDownloadResponse_MoreInfo* temp = more_info_;
  more_info_ = NULL;
  return temp;
}

// optional bytes token = 3;
inline bool ClientDownloadResponse::has_token() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientDownloadResponse::set_has_token() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientDownloadResponse::clear_has_token() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientDownloadResponse::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& ClientDownloadResponse::token() const {
  return *token_;
}
inline void ClientDownloadResponse::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void ClientDownloadResponse::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void ClientDownloadResponse::set_token(const void* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientDownloadResponse::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* ClientDownloadResponse::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace safe_browsing

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_csd_2eproto__INCLUDED
